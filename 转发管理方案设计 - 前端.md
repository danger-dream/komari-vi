# 转发管理方案设计

## 一、 总体方案回顾与架构确认

用户的需求:
```
您知道 [realm](https://github.com/zhboner/realm/tree/master) 吗？一个用 Rust 编写的简单、高性能的中继服务器。我想在当前系统中深度集成它。
我的想法是，当前系统中，已经是主控、被控的模式，且系统本身是带ssh、命令下方等远程执行功能的，并且有系统、网络监控上报，那么顺着其本身的能力接入realm这种中继服务似乎很不错。

所以我想新增一个转发管理的功能（新增一个"转发管理"的菜单），进入页面后，是一个配置列表，可点击新增按钮来创建一份新的转发配置，转发配置应该使用侧滑框来进行展示，其中要填写、配置的内容如下：
- 配置名称，用户可任意填写，为空时使用"转发_{入口节点名称}_{入口端口}"来生成
- 入口， 入口需要选择一个服务器节点，并填写一个端口号，其中端口号可以是任意1000-65535之间的数字，也可以是使用逗号分割的多个端口（表示在这些端口里任选一个使用），也可以是使用"-"进行分割的2个端口（表示在一个区间内进行任选使用，比如10000-20000,这1万个端口任选）。
此处的ui,应该是一行两列，左边选择服务器，右边输入端口。
- 类型，该类型非常重要，影响接下来的所有配置，分为：中转、中继组、链式中继。这3类：
1. 中转，即从入口直接转发到目标。
比如：入口为服务器A，端口为8881, 要转发的目标是自定义服务器："1.1.1.1:53"。
流量路径是：A:8881 <-> 1.1.1.1:53
2. 中继组，即从入口开始，使用特定算法，转发到下一组服务器中的一个，再通过该服务器转发到目标。
比如：入口为服务器A，端口为8881, 中继服务器是服务器B、服务器C、服务器D，目标服务器是："1.1.1.1:53"。
流量路径是：A:8881 <-> (中继：B、C、D) <-> (算法) -> 1.1.1.1:53
此处的算法可能是：负载均衡-循环、负责均衡-iphash、智能算法-按延迟、智能算法-按速度。其中的智能算法，仅预留出选项，后期再完善功能。
比如完整的流量路径是：A:8881 <-> (负责均衡：B:14785) <-> 1.1.1.1:53
3. 链式中继，该类型可无限叠加下一跳的中转、中继组。
比如：入口为服务器A，端口为8881,中继服务器是服务器B、服务器C、服务器D，下一跳为中转服务器G:11557，目标服务器是："1.1.1.1:53"。
完整流量的路径可能是：A:8881 <-> (负责均衡-循环：B:14785) <-> G:11557 <-> 1.1.1.1:53
下一跳地址可无限增加，做到：入口 <-> 中转、中继组 <-> 中转、中继组 <-> ..... <-> 目标

- 接下来的配置就需要根据类型来进行增加:
1. 中转，需要2行配置
    第1行为目标类型，单选框，分为: 1.从服务器选择、2.自定义目标
    第2行为2列，若选择的是从服务器选择，则第一列是服务器下拉选择框，否则是目标地址输入框，第二列则是端口输入框。端口输入框必须是固定的端口。

2. 中继组
    首先是中继节点列表，有个选择按钮可以点击后弹框选择多个服务器。然后将选择的服务器一个个按一行两列的方式列出来，第一列是服务器下拉选择框，第二列则是端口输入框，该端口允许固定、按逗号分割的，按"-"的区间的。
    然后是中继类型： 负载均衡-循环、负责均衡-iphash、智能算法-按延迟、智能算法-按速度。其中的智能算法，仅预留出选项，后期再完善功能。
    然后就是和中转一样的目标配置。

3. 链式中继
    链式中继会生成一个块来包括每份配置。
    首先是选择中继模式： 中转、中继组。
    此处若选择中转的话，则与上方的中转意思差不多，但第一行就不是目标类型，而是中转类型，自定义目标也需要更改为中转目标。
    若选择的是中继组就和上方一致。
    配置完成后，下方会有2个按钮，1是新增节点，2是新增目标。
    若新增中继，则继续生成新的块来让用户配置，直至配置新增目标。 若是目标，则按第1点中转部分的来。

这样配置完成后，就能根据配置来生成各节点的reaml配置，并下发任务到各服务器节点，由agent端来根据配置信息启动、监控、管理reaml。

--------
agent做为智能调度器，realm作为流量转发核心的混合模式非常非常好，就该这样来做才对。realm的高稳定性+高性能作为核心再合适不过了。

流量统计我认为还是直接使用iptables的方案来最好，既然你说云长都在使用，那说明这个方案可行性高、准确、可靠。

其次我需要增加一些功能：
- 首先是中继算法类型，之前提到的是负载均衡、hash、智能算法：按延迟、智能算法：按速度。现在改为：轮询和随机负载均衡，、智能算法：按延迟、智能算法：按速度。智能算法比较复杂，我还没完整想好，还是先预留选择，不进行实现。
- 增加一个监控面板，能根据 netfilter(iptables/nftables) 计数信息显示比如连接数、实时流量、链路状态（正常/降级/故障）、当前使用的中继节点，各节点的延迟
- 增加一个"链路拓扑图"展示：
  [Client] -> [入口节点A:8881] -> [中继组: B/C/D (负载均衡)] -> [目标: 1.1.1.1:53]
                                          ↓
                                     选中: B (延迟12ms)
- 增加端口冲突检测。在用户填写端口时，进行实时的异步检查
- 增加端口自动放行。基于agent端当前系统的防火墙类型（iptables、nftables、ufw...）来智能放行端口。
- realm配置编辑。用户可以在界面中配置各agent最终使用的realm配置，并且进行修改、下发执行。
```

我们将遵循 **`Web UI (配置) -> Komari主控 (编排与存储) -> Komari-Agent (执行与监控) -> [netfilter(nftables/iptables) + realm]`** 的核心架构。Agent负责“脏活累活”（防火墙端口放行、netfilter流量统计、realm安装检测/运行管理），Realm负责高性能转发。

## 二、 详细功能设计与实现方案

### 1. 数据模型设计 (数据库)

为了支持新功能，我们需要设计/更新两张核心的表：

**`forward_rules` - 转发规则配置表**

| 字段名                  | 类型        | 描述                                                       | 示例                                     |
| :---------------------- | :---------- | :--------------------------------------------------------- | :--------------------------------------- |
| `id`                    | `INTEGER`   | 主键，自增                                                 | `1`                                      |
| `is_enabled`            | `BOOLEAN`   | 是否启用该规则，用于控制规则的启停状态                         | `true`                                   |
| `name`                  | `VARCHAR`   | 规则名称                                                   | `My-Game-Relay`                          |
| `group_name`            | `VARCHAR`   | 分组名称，用于UI上的分类展示                                 | `游戏加速`                               |
| `sort_order`            | `INTEGER`   | 排序字段，用于自定义排序                                     | `10`                                     |
| `tags`                  | `JSONB`     | 标签列表，用于搜索和筛选                                     | `["tcp", "高可用"]`                        |
| `notes`                 | `TEXT`      | 备注信息                                                   | `此规则用于亚太地区的游戏加速`             |
| `type`                  | `ENUM`      | 规则类型: `direct`, `relay_group`, `chain`                 | `relay_group`                          |
| `status`                | `ENUM`      | 运行状态: `stopped`, `running`, `error`                    | `running`                                |
| `config_json`           | `JSONB`     | 存储详细的、结构化的UI配置                                   | (见下方JSON结构)                         |
| `total_connections`     | `BIGINT`    | 聚合统计：总连接数（定期从node_stats聚合）                    | `1200`                                   |
| `total_traffic_in`      | `BIGINT`    | 聚合统计：总流入流量（Bytes）                                | `5432100000`                             |
| `total_traffic_out`     | `BIGINT`    | 聚合统计：总流出流量（Bytes）                                | `1234500000`                             |
| `created_at`            | `TIMESTAMP` | 创建时间                                                   |                                          |
| `updated_at`            | `TIMESTAMP` | 更新时间                                                   |                                          |

**`config_json` 详细结构示例**:

**注意**：所有node_id字段使用Client表的UUID（varchar(36)字符串格式）

```json
// type = "direct" - 直连模式
{
    "entry_node_id": "550e8400-e29b-41d4-a716-446655440000",  // 入口节点UUID
    "entry_port": "8881",                    // 入口端口配置："8881" | "8000-9000" | "8881,8882,8883"
    "entry_current_port": 8881,              // 当前实际使用的端口（由CHECK_PORT任务返回）
    "entry_realm_config": "[endpoints]\n...", // 入口节点的realm配置（TOML格式）
    "protocol": "tcp",                       // 协议类型: "tcp" | "udp" | "both"
    "target_type": "custom",                 // 目标类型: "node" | "custom"
    "target_node_id": null,                  // 若target_type为node时为UUID，custom时为null
    "target_host": "1.1.1.1",                // 若target_type为node时为null，custom时为IP或域名
    "target_port": 53
}
//  流量路径: [Client] -> [入口节点:8881] -> [目标: 1.1.1.1:53]

// type = "relay_group" - 中继组模式
{
    "entry_node_id": "550e8400-e29b-41d4-a716-446655440000",
    "entry_port": "8881,8882,8883",
    "entry_current_port": 8881,
    "entry_realm_config": "[endpoints]\n...",
    "protocol": "tcp",
    "relays": [
        {
            "node_id": "660e8400-e29b-41d4-a716-446655440001",  // 中继节点UUID
            "port": "10000-20000",                              // 端口配置
            "current_port": 10715,                              // 当前使用端口
            "realm_config": "[endpoints]\n...",                 // 该节点的realm配置
            "sort_order": 1                                     // 优先级/权重（数字越小优先级越高）
        },
        {
            "node_id": "660e8400-e29b-41d4-a716-446655440002",
            "port": "15000",
            "current_port": 15000,
            "realm_config": "[endpoints]\n...",
            "sort_order": 2                                     // 优先级次之
        },
        {
            "node_id": "660e8400-e29b-41d4-a716-446655440003",
            "port": "18000-19000",
            "current_port": 18921,
            "realm_config": "[endpoints]\n...",
            "sort_order": 3                                     // 优先级最低
        }
    ],
    "strategy": "roundrobin",                // 负载均衡策略: "roundrobin" | "iphash" | "priority"
    "active_relay_node_id": "660e8400-e29b-41d4-a716-446655440001",  // 当前活跃的中继节点（仅priority策略使用）
    "target_type": "node",
    "target_node_id": "770e8400-e29b-41d4-a716-446655440004",
    "target_host": null,
    "target_port": 4188
}
//  流量路径: [Client] -> [入口:8881] -> [中继组: relay1/2/3 (roundrobin)] -> [目标节点:4188]

// type = "chain" - 链式中继模式
{
    "entry_node_id": "550e8400-e29b-41d4-a716-446655440000",
    "entry_port": "8881",
    "entry_current_port": 8881,
    "entry_realm_config": "[endpoints]\n...",
    "protocol": "tcp",
    "hops": [                                    // 注意：这里是hops不是hips
        {
            "type": "relay_group",               // 第一跳：中继组
            "relays": [
                {
                    "node_id": "660e8400-e29b-41d4-a716-446655440001",
                    "port": "10000-20000",
                    "current_port": 10715,
                    "realm_config": "[endpoints]\n...",
                    "sort_order": 1
                },
                {
                    "node_id": "660e8400-e29b-41d4-a716-446655440002",
                    "port": "15000",
                    "current_port": 15000,
                    "realm_config": "[endpoints]\n...",
                    "sort_order": 2
                }
            ],
            "strategy": "roundrobin",
            "active_relay_node_id": ""
        },
        {
            "type": "direct",                    // 第二跳：直连
            "node_id": "880e8400-e29b-41d4-a716-446655440005",
            "port": "11557",
            "current_port": 11557,
            "realm_config": "[endpoints]\n..."
        }
    ],
    "target_type": "custom",
    "target_node_id": null,
    "target_host": "1.1.1.1",
    "target_port": 53
}
//  流量路径: [Client] -> [入口:8881] -> [中继组: relay1/2 (roundrobin)] -> [直连节点:11557] -> [目标: 1.1.1.1:53]
```

**关键说明**：
1. **所有node_id字段**：使用Client.UUID（36字符的UUID字符串）
2. **target_node_id和target_host互斥**：
   - target_type="node"时：target_node_id有值，target_host为null
   - target_type="custom"时：target_node_id为null，target_host有值
3. **protocol字段**：控制Realm的`no_tcp`和`use_udp`配置
4. **realm_config字段**：存储完整的TOML配置，用于高级用户手动编辑或系统自动生成后的最终版本
5. **sort_order字段**（重要）：
   - **不是**简单的UI显示排序
   - 代表节点的**优先级/权重**，数字越小优先级越高
   - 在不同策略下有不同含义：
     - `roundrobin`: 作为权重，Realm配置为 `balance = "roundrobin: w1, w2, w3"`
     - `iphash`: 仅用于UI显示顺序，实际由IP哈希决定
     - `priority`: 决定故障转移优先级（核心功能，见下方详细说明）

---

### **1.1 负载均衡策略详解**

系统支持三种负载均衡策略，其中两种由Realm原生支持，一种由Agent智能调度实现。

#### **策略1: roundrobin (轮询)**

**实现方式**：Realm原生支持

**工作原理**：
- 按顺序将连接分配给后端节点
- 支持权重配置，根据`sort_order`分配权重
- Realm配置示例：`balance = "roundrobin: 1, 2, 3"`（sort_order=1的节点权重为1，以此类推）

**适用场景**：
- 多个节点性能相近
- 需要均匀分配流量
- 不需要会话保持

生成的Realm配置：
```toml
[[endpoints]]
remote = "node-a-ip:port"
extra_remotes = ["node-b-ip:port", "node-c-ip:port"]
balance = "roundrobin: 3, 2, 1"
```

---

#### **策略2: iphash (IP哈希)**

**实现方式**：Realm原生支持

**工作原理**：
- 根据客户端IP进行哈希
- 确保同一客户端始终连接到同一后端节点
- `sort_order`仅用于UI显示顺序，不影响实际分配

**适用场景**：
- 需要会话保持
- 需要客户端与特定节点保持长连接

生成的Realm配置：
```toml
[[endpoints]]
remote = "node-a-ip:port"
extra_remotes = ["node-b-ip:port", "node-c-ip:port"]
balance = "iphash"
```

---

#### **策略3: priority (优先级故障转移) ⭐️ 新增**

**实现方式**：Agent智能调度 + Realm动态配置

**工作原理**（核心功能）：
1. **优先级定义**：`sort_order`数字越小，优先级越高
2. **主节点优先**：始终尝试连接优先级最高的可用节点
3. **自动故障转移**：当前节点不可达时，自动切换到次优先级节点
4. **自动回切**：当更高优先级节点恢复时，自动切换回去

**详细流程**：

```
初始状态：A(sort_order=1), B(sort_order=2), C(sort_order=3)
         当前活跃节点：A

场景1: A节点故障
  ├─ Agent检测到A不可达
  ├─ 自动切换到B节点（次优先级）
  ├─ 更新 active_relay_node_id = B
  ├─ 重新生成Realm配置（remote指向B）
  └─ 下发配置并重启Realm进程

场景2: A节点恢复（当前活跃节点为B）
  ├─ Agent定期健康检查发现A恢复
  ├─ A的优先级(1) > B的优先级(2)
  ├─ 自动切换回A节点
  ├─ 更新 active_relay_node_id = A
  └─ 重新生成Realm配置并下发

场景3: B也故障（当前活跃节点为B）
  ├─ Agent检测到B不可达
  ├─ A仍不可达，切换到C节点
  ├─ 更新 active_relay_node_id = C
  └─ 重新生成Realm配置

场景4: 所有节点都故障
  ├─ 链路状态标记为 faulty
  ├─ 发送告警通知
  └─ 规则状态变为 error
```

**当前活跃节点为A时，生成的Realm配置**：
```toml
[[endpoints]]
remote = "node-a-ip:port"  # 只指向当前活跃节点
# 注意：不使用extra_remotes，因为切换由Agent控制
```

**Agent健康检查逻辑**（伪代码）：
```go
func (a *Agent) CheckPriorityStrategy(rule *ForwardRule) {
    relays := rule.ConfigJSON.Relays
    currentActive := rule.ConfigJSON.ActiveRelayNodeID

    // 1. 按sort_order排序（优先级从高到低）
    sort.Slice(relays, func(i, j int) bool {
        return relays[i].SortOrder < relays[j].SortOrder
    })

    // 2. 找到当前活跃节点的优先级
    currentPriority := getNodePriority(currentActive, relays)

    // 3. 检查是否有更高优先级的节点可用（自动回切）
    for _, relay := range relays {
        if relay.SortOrder < currentPriority {
            // 发现更高优先级节点，检查是否可达
            if isNodeReachable(relay.NodeID) {
                // 可达，切换到这个节点
                switchToNode(rule.ID, relay.NodeID, "priority_failback")
                return
            }
        }
    }

    // 4. 检查当前节点是否还可达
    if !isNodeReachable(currentActive) {
        // 当前节点不可达，查找下一个可用节点（故障转移）
        for _, relay := range relays {
            if relay.SortOrder > currentPriority && isNodeReachable(relay.NodeID) {
                // 找到可用的备用节点
                switchToNode(rule.ID, relay.NodeID, "priority_failover")
                return
            }
        }
        // 没有可用节点，标记为故障
        markRuleAsFaulty(rule.ID)
    }
}

func switchToNode(ruleID int, newNodeID string, reason string) {
    // 1. 获取当前规则信息
    rule := getRule(ruleID)
    oldNodeID := rule.ConfigJSON.ActiveRelayNodeID

    // 2. 更新本地记录：active_relay_node_id
    rule.ConfigJSON.ActiveRelayNodeID = newNodeID

    // 3. 重新生成Realm配置（入口节点）
    entryNodeID := rule.ConfigJSON.EntryNodeID
    newConfig := generateRealmConfig(rule)

    // 4. 下发配置并重启Realm（仅入口节点需要更新）
    updateRealmConfig(entryNodeID, ruleID, newConfig)

    // 5. ⭐ 主动上报配置变更到Server
    a.ReportConfigChange(ruleID, entryNodeID, newConfig, map[string]interface{}{
        "active_relay_node_id": newNodeID,
    }, reason)  // reason: "priority_failover" 或 "priority_failback"

    // 6. 记录切换事件
    log.Infof("Rule %d switched from node %s to %s (reason: %s)", ruleID, oldNodeID, newNodeID, reason)

    // 7. 触发告警（如果配置了）
    if reason == "priority_failover" {
        sendAlert(ruleID, "节点故障转移", fmt.Sprintf("规则 %d 从节点 %s 切换到 %s", ruleID, oldNodeID, newNodeID))
    }
}
```

**适用场景**：
- 有明确的主备节点关系
- 希望主节点恢复后自动回切
- 需要最小化节点切换（只在必要时切换）

**优势**：
- ✅ 主节点优先：正常情况下始终使用最优节点
- ✅ 自动故障转移：主节点故障时无缝切换到备用节点
- ✅ 自动回切：主节点恢复后自动切换回去
- ✅ 多级备份：支持多个备用节点

---

### **1.2 策略对比表**

| 特性                 | roundrobin   | iphash       | priority (新增)   |
| :------------------ | :---------- | :----------- | :---------------- |
| 实现方式             | Realm原生    | Realm原生     | Agent智能调度      |
| 负载分配             | 按权重轮询    | IP哈希       | 优先级故障转移     |
| 会话保持             | ❌          | ✅           | ✅                |
| 自动故障转移         | ✅          | ✅           | ✅                |
| 自动回切             | ❌          | ❌           | ✅ **（核心优势）** |
| sort_order含义      | 权重        | 显示顺序      | 优先级（核心参数）  |
| 适用场景             | 流量均衡     | 会话保持      | 主备切换          |
| 配置复杂度           | 低          | 低           | 中               |
| Agent处理开销       | 无          | 无           | 低（仅健康检查）   |

---

**`forward_stats` - 转发规则实时状态与统计表**

这张表由Agent定时上报数据，主控进行更新，供监控面板和拓扑图使用。

| 字段名                 | 类型        | 描述                                     | 示例                                |
| :--------------------- | :---------- | :--------------------------------------- | :---------------------------------- |
| `id`                   | `INTEGER`   | 主键，自增                               | `1`                                 |
| `rule_id`              | `INTEGER`   | `forward_rules`的外键                  | `1`                                  |
| `node_id`              | `VARCHAR(36)` | 节点UUID（外键关联Client表）           | `"550e8400-e29b-41d4-a716-446655440000"` |
| `link_status`          | `ENUM`      | 链路状态: `healthy`, `degraded`, `faulty` | `healthy`                           |
| `active_connections`   | `INTEGER`   | 当前连接数（来自 `ss` / `netstat`）       | `15`                                |
| `traffic_in_bytes`     | `BIGINT`    | 入口总流量（来自 netfilter 计数：nftables 优先，iptables 兜底） | `1024000`                           |
| `traffic_out_bytes`    | `BIGINT`    | 出口总流量（来自 netfilter 计数：nftables 优先，iptables 兜底） | `2048000`                           |
| `realtime_bps_in`      | `BIGINT`    | 实时入口带宽 (bits/s)                    | `56000`                             |
| `realtime_bps_out`     | `BIGINT`    | 实时出口带宽 (bits/s)                    | `128000`                            |
| `active_relay_node_id` | `VARCHAR(36)` | 当前选中的中继节点UUID                 | `"660e8400-e29b-41d4-a716-446655440001"` |
| `nodes_latency`        | `JSONB`     | 下一跳节点延迟信息                       | `{"660e8400-...": 12, "770e8400-...": 25}` (node_uuid: ms) |
| `last_updated_at`      | `TIMESTAMP` | 最后更新时间                             |                                     |

唯一索引：`idx_rule_node` (rule_id, node_id) - 确保同一规则的同一节点只有一条统计记录

---

### 2. 主控端 (Komari) API 设计

需要新增和修改以下API端点：

*   `POST /api/v1/forwards`: 创建规则。
*   `PUT /api/v1/forwards/{id}`: 更新规则。
*   `GET /api/v1/forwards`: 获取所有规则列表。
*   `DELETE /api/v1/forwards/{id}`: 删除规则。
*   `GET /api/v1/forwards/{id}/stats`: 获取指定规则的详细监控数据，用于填充监控面板。
*   `POST /api/v1/forwards/{id}/enable`: 启用规则。若规则处于运行状态，则不做任何处理。若在未运行状态，则需要先停止规则.
*   `POST /api/v1/forwards/{id}/disable`: 停用规则。
*   `GET /api/v1/forwards/{id}/topology`: 获取渲染拓扑图所需的数据。
*   `POST /api/v1/agents/run_task`: 这是一个统一的Agent任务下发API，用于取代多个特定的任务接口，提高可扩展性。
    - **Request Body**:
        ```json
        {
          "node_ids": ["550e8400-e29b-41d4-a716-446655440000", "660e8400-e29b-41d4-a716-446655440001"],
          "task_type": "PREPARE_FORWARD_ENV", 
          "payload": {
            "realm_download_url": ""
          }
        }
        ```
    - **说明**：`realm_download_url` 允许为空。为空时由 Agent 使用自身的 `endpoint + token + GOOS/GOARCH` 自动拼接并访问主控的公共下载接口：`/api/v1/realm/binaries/download?token=...&os=...&arch=...`（优先下载默认版本）。
    - **`task_type`** 支持的类型包括（详见第9节）:
        - `CHECK_PORT`: 端口检测并返回可用端口
        - `PREPARE_FORWARD_ENV`: 转发环境依赖预检查与安装
        - `START_REALM`: 启动Realm进程
        - `STOP_REALM`: 停止Realm进程
        - `UPDATE_REALM`: 热更新Realm配置
        - `GET_REALM_LOG`: 获取Realm日志
        - `CLEAR_REALM_LOG`: 清空Realm日志
        - `DELETE_REALM_LOG`: 删除Realm日志
        - `TEST_CONNECTIVITY`: 测试连通性

*   `POST /api/v1/forwards/test-connectivity`: 测试链路连通性（保存前测试）。
*   `POST /api/v1/forwards/{id}/alert-config`: 配置告警设置。
*   `GET /api/v1/forwards/{id}/alert-history`: 获取告警历史记录。
*   `POST /api/v1/forwards/{id}/alert-history/{alertId}/acknowledge`: 确认告警。
*   `GET /api/v1/forwards/{id}/logs`: 获取指定规则的所有节点日志列表。
*   `GET /api/v1/forwards/{id}/logs/{nodeId}`: 获取指定节点的日志内容。
*   `DELETE /api/v1/forwards/{id}/logs/{nodeId}`: 删除指定节点的日志。
*   `POST /api/v1/realm/binaries`: 上传Realm二进制文件。
*   `GET /api/v1/realm/binaries`: 获取所有Realm二进制文件列表。
*   `DELETE /api/v1/realm/binaries/{id}`: 删除Realm二进制文件。
*   `GET /api/v1/realm/default-config`: 获取默认Realm配置模板。
*   `PUT /api/v1/realm/default-config`: 更新默认Realm配置模板。
*   `GET /api/v1/forwards/system-settings`: 获取系统参数配置。
*   `PUT /api/v1/forwards/system-settings`: 更新系统参数配置。
*   `GET /api/v1/forwards/ws`: 前端订阅转发事件的WebSocket通道（如 `forward_config_updated` / `forward_stats_update`），用于实时刷新UI。
*   `POST /api/v1/forwards/{id}/config/sync`: **Agent上报配置变更**。当Agent因故障转移等原因修改了Realm配置后，通过此接口将最新配置同步到主控。
    - **Request Body**:
        ```json
        {
          "node_id": "550e8400-...",
          "realm_config": "[endpoints]\nbind = ...",
          "config_json_updates": {
            "active_relay_node_id": "660e8400-...",
            "entry_current_port": 8882
          },
          "reason": "priority_failover"  // 变更原因: priority_failover, priority_failback, port_conflict
        }
        ```
    - **说明**：此API由Agent主动调用，Server接收后更新`forward_rules`表的`realm_config`和`config_json`字段，并通过WebSocket推送通知前端刷新UI。

---

### 3. 被控端 (Komari-Agent) 核心逻辑增强

1.  **防火墙管理器**:
    *   **智能检测（按“谁在管规则”优先）**：
        1. `firewalld`：若 `firewall-cmd --state` 返回 `running`，认为 firewalld 在管规则（优先使用 firewalld 官方接口，避免混用导致规则集不一致）。
        2. `ufw`：若 `ufw status` 显示 `Status: active`，认为 ufw 在管规则。
        3. `iptables/ip6tables`：若系统存在 `iptables` 或 `ip6tables`，可直接操作（注意：可能是 iptables-nft 后端，但接口仍可用）。
        4. `nft`：若存在 `nft` 且系统存在可用的 `inet/ip/ip6` 的 `filter` 表输入链（或兼容链），可做最小放行。
        5. 否则：认为当前未启用/未识别到防火墙管理器（`none`），不做端口放行。
    *   **统一接口**: 实现 `FirewallManager`，提供 `OpenPort(port, protocol)` / `ClosePort(port, protocol)`。
    *   **“只删自己加的”原则（强约束）**：为了避免误删用户已有规则，所有放行规则必须带可识别标记，并且 `ClosePort` 只能删除带标记的规则：
        - `ufw`：使用 `ufw allow PORT/PROTO comment TAG` 添加，关闭时用 `ufw status numbered` 定位包含 `TAG` 的条目，再用 `ufw --force delete NUM` 删除。
        - `iptables/ip6tables`：优先使用 `-m comment --comment TAG` 添加规则；关闭时只删除带同样 `comment` 的规则。若系统不支持 comment 模块，则退化为“仅本次进程内记录 + 尽量不自动删除”（避免误删用户规则）。
        - `nft`：所有规则使用 `comment "TAG"`，删除时用 `nft -a` 获取 `handle` 后再删除（避免按规则文本匹配失败）。
        - `firewalld`：用 `firewall-cmd --add-port PORT/PROTO` 开放（运行时规则集），并且仅关闭本进程曾打开过的端口（不关闭原本就开放的端口）。
    *   **参考（源头文档）**：`ufw(8)`、`firewall-cmd(1)`、`nft(8)`、`iptables(8)`（建议在目标机直接 `man ufw` / `man nft` / `man iptables` 查看）。
        - nftables（`nft(8)`）：https://www.netfilter.org/projects/nftables/manpage.html
        - iptables（`iptables(8)`）：https://www.netfilter.org/projects/iptables/manpage.html
        - iptables 扩展（`iptables-extensions(8)`，含 `comment` 匹配扩展；建议目标机 `man iptables-extensions` 查看）
        - ufw（`ufw(8)`，Ubuntu manpages）：https://manpages.ubuntu.com/manpages/jammy/man8/ufw.8.html
        - firewalld（`firewall-cmd(1)`）：https://firewalld.org/documentation/man-pages/firewall-cmd.html

2.  **端口冲突检测任务**:
    *   Agent增加一个任务处理器，用于执行端口检测。
    *   收到任务后，执行 `ss -tlnp | grep ':8881'` 或 `netstat -tlnp | grep ':8881'`....。如果命令有输出，则表示端口被占用，返回冲突信息。

3.  **转发环境检测**
    *   **触发时机**：主控在**启用/启动规则**、以及**热更新新增节点**前，会先下发 `PREPARE_FORWARD_ENV`，确保依赖满足再执行 `START_REALM` / `UPDATE_REALM`。
    *   接收到来自主控的检测请求后，Agent需要确保“统计能力”可用（与端口放行无关）：
        - 若系统已启用 `nftables`（存在可用的 `input/output` hook 基础链），则优先使用 nftables 计数器做流量统计。
        - 否则：确保系统存在 `iptables`/`ip6tables`（若没有则尝试安装 `iptables` 作为保底统计方案）。
    *   然后检查 `realm` 二进制文件是否存在；若没有则执行下载并安装到 `/usr/local/bin/realm`，并确保可执行（`chmod +x`）：
        - 若主控下发了 `realm_download_url`：直接使用该 URL 下载。
        - 若 `realm_download_url` 为空：Agent 自动使用自身的 `endpoint + token + GOOS/GOARCH` 拼接下载地址，访问主控的公共下载接口（优先默认版本）。

4.  **Netfilter流量统计模块（nftables 优先，iptables 兜底）**:
    *   **原则**：统计必须“只计数不改语义”。因此统计链（无论 nft/iptables）都应以 `RETURN` 结束，绝不能在统计链里使用 `ACCEPT` 改变原有防火墙默认策略（尤其默认 `DROP` 的机器会产生重大安全风险）。
    *   **链命名**：为避免触发链名长度限制，使用短且稳定的链名（示例）：`KF_{rule_id_hex}_{port_hex}_IN/OUT`。
    *   **iptables 方案（兜底）**：当 nftables 不可用时，使用 iptables/ip6tables 计数链。
        ```bash
        # 1) 创建统计链（链内只 RETURN 用于计数）
        iptables -N KF_{rule_hex}_{port_hex}_IN 2>/dev/null || true
        iptables -F KF_{rule_hex}_{port_hex}_IN
        iptables -A KF_{rule_hex}_{port_hex}_IN -j RETURN

        iptables -N KF_{rule_hex}_{port_hex}_OUT 2>/dev/null || true
        iptables -F KF_{rule_hex}_{port_hex}_OUT
        iptables -A KF_{rule_hex}_{port_hex}_OUT -j RETURN

        # 2) INPUT：按监听端口导向统计链（示例：tcp/8881）
        iptables -C INPUT -p tcp --dport 8881 -j KF_{rule_hex}_{port_hex}_IN 2>/dev/null || \
          iptables -I INPUT -p tcp --dport 8881 -j KF_{rule_hex}_{port_hex}_IN

        # 3) OUTPUT：优先按 realm 配置里的 remote/extra_remotes 的目标IP:Port 计数；缺失时才回退到 sport=listenPort
        iptables -C OUTPUT -p tcp -d <目标IP> --dport <目标Port> -j KF_{rule_hex}_{port_hex}_OUT 2>/dev/null || \
          iptables -I OUTPUT -p tcp -d <目标IP> --dport <目标Port> -j KF_{rule_hex}_{port_hex}_OUT

        iptables -C OUTPUT -p tcp --sport 8881 -j KF_{rule_hex}_{port_hex}_OUT 2>/dev/null || \
          iptables -I OUTPUT -p tcp --sport 8881 -j KF_{rule_hex}_{port_hex}_OUT
        ```
        **IPv6说明**：
        - 当目标为 IPv6（例如 `2001:db8::1:443`）时，Realm 配置中会使用 `remote = "[2001:db8::1]:443"` 形式（带 `[]`）。
        - Agent 在统计与端口放行时会同时适配 `iptables`（IPv4）与 `ip6tables`（IPv6），nftables 下则用 `ip/ip6` family 匹配 `daddr`。

    *   **nftables 方案（优先）**：仅在系统已经存在可用的 `input/output` hook 基础链时启用；Agent 不会自动创建/重写基础链（避免改变防火墙语义）。
        ```bash
        # 1) 创建普通统计链（无 hook），链内 counter + return
        nft add chain inet filter KF_{rule_hex}_{port_hex}_IN 2>/dev/null || true
        nft flush chain inet filter KF_{rule_hex}_{port_hex}_IN
        nft add rule inet filter KF_{rule_hex}_{port_hex}_IN counter return comment "komari_fwd_stats_in:{rule_id}:{port}"

        nft add chain inet filter KF_{rule_hex}_{port_hex}_OUT 2>/dev/null || true
        nft flush chain inet filter KF_{rule_hex}_{port_hex}_OUT
        nft add rule inet filter KF_{rule_hex}_{port_hex}_OUT counter return comment "komari_fwd_stats_out:{rule_id}:{port}"

        # 2) 将基础链流量 jump 到统计链（示例：tcp/8881）
        # 注意：示例假设基础链名为 input/output；实际环境应以当前 ruleset 的基础链名为准。
        nft insert rule inet filter input index 0 tcp dport 8881 jump KF_{rule_hex}_{port_hex}_IN comment "komari_fwd_jump_in:{rule_id}:{port}:tcp"

        # 3) OUTPUT：优先按 daddr+dport（ip/ip6 family），缺失时回退 sport=listenPort
        nft insert rule inet filter output index 0 ip daddr <IPv4目标IP> tcp dport <目标Port> jump KF_{rule_hex}_{port_hex}_OUT comment "komari_fwd_jump_out:{rule_id}:{port}:tcp:<目标IP>:<目标Port>"
        nft insert rule inet filter output index 0 tcp sport 8881 jump KF_{rule_hex}_{port_hex}_OUT comment "komari_fwd_jump_out:{rule_id}:{port}:tcp:sport"
        ```

    *   **定时抓取**:
        - iptables：周期执行 `iptables -nvxL <CHAIN>` / `ip6tables -nvxL <CHAIN>`，解析 `bytes` 列。
        - nftables：周期执行 `nft -j list chain <family> <table> <chain>`，解析 `counter.bytes`。
    *   **解析与计算**: 解析命令输出，提取`bytes`列的数值。通过与上一次的差值和时间间隔，计算出实时的`bps`（bits per second）。
    *   **数据上报**: 将连接数、总流量、实时速率等数据打包，通过WebSocket或HTTP上报给主控。

5.  **健康探测与状态上报**:
    *   **探测职责**: 为了避免重复探测，明确职责：**只有当前节点的Agent需要探测它的直连下一跳节点**。例如，入口A探测中继B/C/D；如果B的下一跳是G，则由B的Agent负责探测G。
    *   **探测方法**: 探测通过对目标`IP:Port`发起TCP握手来完成，并记录完成握手所需的时间作为延迟。
    *   **数据上报**: 每个执行探测的Agent，将其探测到的下一跳延迟信息（如`{"nodes_latency": {"124": 12, "125": 25}}`）上报给主控，由主控更新至`forward_stats`表中对应节点的记录。
    *   **链路状态判断**: **入口节点Agent**拥有最高判断权。它除了探测自己的下一跳，还会额外执行一个**端到端**的链路测试。根据“下一跳连通性”和“端到端连通性”的组合结果，来最终确定整条链路的`link_status` (`healthy`, `degraded`, `faulty`)，并将这个最终状态上报，由主控更新。

6.  **断线 / 重连（保持转发不中断）**：
    *   **目标**：当 Agent 与主控 WS 连接中断时，**不影响已运行的转发**（Realm 进程继续运行）；当连接恢复时，自动恢复统计上报与 priority 监控。
    *   **策略**：
        - 连接中断：Agent 只停止“上报相关”的循环（统计采集、priority 监控的上报），避免对已断开的连接持续写入导致报错；**不停止 Realm 进程**。
        - 连接恢复：Agent 重新绑定 WS 连接并恢复统计上报；同时向主控发送 `forward_resync_request`，由主控按当前数据库状态对该节点进行一次“期望状态对齐”（见下一节）。

7.  **Agent 异常重启（自动对齐期望状态）**：
    *   **问题**：Agent 进程异常重启后，内存态会丢失，但旧 Agent 启动的 Realm 进程、netfilter 统计链、以及部分防火墙放行可能仍在。
    *   **机制**：
        1) Agent 连接/重连成功后，主动发 `forward_resync_request` 给主控。
        2) 主控遍历所有规则，筛选出“与该节点相关”的规则：
           - 若规则 **未启用** 或 `status != running`：向该节点下发 `STOP_REALM`（best-effort 清理遗留）。
           - 若规则 **已启用** 且 `status == running`：先下发 `PREPARE_FORWARD_ENV`，再下发 `START_REALM`（确保依赖+确保应当运行）。
        3) Agent 侧的 `START_REALM` 必须是**幂等**：
           - 若发现同一 `rule_id + node_id` 的 Realm 已在运行且配置一致：直接“接管/复用”（恢复统计上报与 priority 监控），并且**不 flush 统计链**，避免流量计数清零。
           - 若发现遗留 Realm 在运行但配置与主控期望不一致：先停止遗留进程，再按主控下发的配置重新启动，确保最终状态与主控一致。
    *   **识别遗留 Realm**（Linux 场景）：通过扫描 `/proc/*/cmdline`，匹配 `realm -c /etc/komari-agent/realm/realm-rule-<id>-node-<uuid>.toml` 来定位进程。
    *   **防火墙遗留说明**：
        - `ufw/iptables/nftables`：由于规则带有可识别标记（comment/handle），可在重启后继续安全删除“自己加的规则”。
        - `firewalld`：由于 `--add-port` 无 comment，Agent 采用“只关闭自己打开过的端口”的保守策略，并持久化自己打开过的端口集合，重启后仍可按记录回收。

---

### 4. 前端 (Komari-Web) UI/UX 详细设计

**重要原则：组件复用与风格统一**

`komari-web` 项目中已包含大量通用组件。在开始开发前，开发者应优先浏览 `komari-web/src/components` 目录，尽可能地复用现有组件，以保证UI的一致性和开发效率。所有新增的UI和交互逻辑，都必须严格遵循项目现有的代码风格、命名规范和整体视觉设计。

**A. 转发规则创建/编辑侧滑框 (增强)**

1.  **协议选择**:
    *   在"入口"部分下方增加协议选择单选框
    *   选项：`TCP` | `UDP` | `TCP+UDP`
    *   默认值：TCP+UDP
    *   该选项影响Realm配置中的`no_tcp`和`use_udp`参数

2.  **中继策略**: "类型"选择"中继组"后，"中继策略"的下拉框选项改为：
    *   `优先级故障转移 (Priority)` - Agent智能调度，主备自动切换。默认
    *   `负载均衡：轮询 (Round Robin)` - Realm原生，按权重分配流量
    *   `负载均衡：IP Hash` - Realm原生，按客户端IP哈希分配
    *   `智能算法：按延迟 (预留)` - 暂不实现
    *   `智能算法：按速度 (预留)` - 暂不实现

    **重要说明**：
    - 选择"轮询"或"IP Hash"时，下方的节点列表显示"权重"列（roundrobin）或"顺序"列（iphash）
    - 选择"优先级故障转移"时，下方的节点列表显示"优先级"列，并提示"数字越小优先级越高，主节点故障时自动切换到备用节点，主节点恢复后自动回切"

3.  **端口实时检测**:
    *   **UI**: 在"入口"部分的端口输入框旁边，增加一个状态图标区域。
    *   **交互**: 当用户输入完端口并失焦（onBlur）时，触发`check_port` API调用。
        *   调用期间，显示一个`Loading`图标。
        *   API返回成功，显示一个绿色的`✔`图标。
        *   API返回冲突，显示一个红色的`✖`图标，并在输入框下方显示错误信息："端口 {port} 已被占用"。

4.  **Realm配置在线编辑**:
    *   在表单最下方，增加一个"高级配置"区域，默认折叠。
    *   展开后，是一个带`TOML`语法高亮的文本编辑器（可使用`react-monaco-editor`等库）。
    *   编辑器左上角有一个下拉框，可切换不同节点的Realm配置。
    *   编辑器右上角有一个开关：`[ 开/关 ] 手动编辑Realm配置`。
    *   **交互**:
        *   默认关闭，编辑器为只读状态，实时显示根据上方表单生成的`realm.toml`预览。
        *   当用户打开开关，上方所有表单项变为`disabled`（不可编辑），编辑器变为可写状态。同时弹出提示："手动编辑将覆盖自动生成的配置，请谨慎操作。"
        *   保存时，如果开关为开，则将编辑器内容存入对应字段。

    *   **⚠️ 配置编辑限制与自动修正**:

        **完全禁止编辑的部分**（UI层面禁用或保存时强制还原）：

        1. **`[endpoints]` 部分**：
           - 原因：此部分由Agent根据转发类型（direct/relay_group/chain）和当前活跃节点动态生成
           - Priority策略下，Agent会在故障转移时自动修改此部分，用户的手动修改会被覆盖
           - UI实现：在编辑器中将此部分标记为灰色背景+只读，或在保存时剥离用户对此部分的修改

        2. **`[log]` 部分**：
           - 原因：Agent依赖固定的日志路径来读取和展示日志
           - 如果用户修改了`file`路径，Agent将无法获取日志内容
           - UI实现：同样标记为只读

        **需要智能修正的部分**（保存时自动校验并修正）：

        3. **`[network]` 部分**：
           - `use_udp`：必须与规则的`protocol`字段一致
             - 如果规则协议为UDP或TCP+UDP，`use_udp`必须为`true`
             - 如果规则协议为TCP，`use_udp`必须为`false`
           - `no_tcp`：同理
             - 如果规则协议为UDP，`no_tcp`必须为`true`
             - 如果规则协议为TCP或TCP+UDP，`no_tcp`必须为`false`
           - **保存逻辑**：Server端在接收到配置更新时，根据`forward_rules.config_json.protocol`字段自动修正这两个参数

        **可安全编辑的部分**：

        4. **`[dns]` 部分**：用户可自定义DNS服务器
        5. **`[network]` 其他参数**：
           - `tcp_timeout`
           - `udp_timeout`
           - `send_proxy`
           - `send_proxy_version`
           - `accept_proxy`
           - `accept_proxy_timeout`

        **实现建议**：
        - 在Monaco Editor中使用装饰器（Decorations）为禁止编辑的行添加灰色背景和锁图标
        - 保存前进行客户端校验，提示用户哪些修改会被忽略
        - Server端保存时执行二次校验和自动修正，并在响应中返回修正后的配置

5.  **节点选择重要说明**:
    *   不管是那种类型的规则，同一个服务器节点只允许使用一次。
    *   选择节点时，需过滤掉非linux系统的服务器节点。

**B. 监控面板页**

当用户在列表页点击一个“运行中”规则的“监控”按钮时，进入此页 (`/forwarding/{id}/dashboard`)。页面采用网格布局，展示多个卡片。

*   **卡片1: 链路拓扑图**
    *   **样式**: 使用div和箭头（或SVG）清晰地画出路径。
    *   **内容**:
        `[客户端]` -> `[入口: {服务器A:8881}]` -> `[中继组: B/C/D (轮询)]` -> `[目标: 1.1.1.1:53]`
    *   **动态高亮**: 在“中继组”卡片下方，用一个明显的箭头和文本指出当前活动的节点及其延迟。
        `↓`
        `当前活动: 服务器B (延迟: 12ms)`
    *   数据来自`/api/v1/forwards/{id}/topology`。

*   **卡片2: 核心状态**
    *   **链路状态**: 一个大的、带颜色的徽章（Badge），显示“健康”、“降级”或“故障”。
    *   **连接数**: 一个醒目的数字，显示当前活动连接数。
    *   **总流量**: 显示 `入口: 1.5 GB / 出口: 3.0 GB`。

*   **卡片3: 实时流量图**
    *   使用`ECharts`或`Recharts`等图表库，绘制两条曲线：入口流量和出口流量。
    *   X轴是时间（最近5分钟），Y轴是速率（Mbps）。数据通过WebSocket或定时轮询`/stats`接口刷新。

*   **卡片4: 中继节点延迟**
    *   一个条形图（Bar Chart）。
    *   每个条代表一个中继节点，条的高度表示其延迟（ms）。
    *   当前活动的节点的条形图用不同的颜色高亮。

*   **卡片5: 节点健康状态**
    *   展示链路中所有节点的健康状态。
    *   每个节点显示为一个卡片，包含：节点名称、IP地址、端口、状态（运行中/停止/异常）。
    *   使用不同颜色的图标表示状态（绿色=正常，黄色=警告，红色=异常）。

*   **卡片6: 告警历史**
    *   显示最近的告警记录（如果配置了告警）。
    *   以时间线形式展示告警事件，包括：时间、告警类型、告警内容。
    *   可点击查看告警详情或确认告警。

**C. 规则列表页**

主页面路径：`/forwarding`

1.  **页面布局**：
    *   顶部工具栏：
        *   左侧：页面标题"转发管理"
        *   右侧：
            *   "系统设置"按钮（进入系统参数设置页面）
            *   "Realm配置"按钮（进入Realm二进制管理页面）
            *   "新建规则"按钮（打开创建侧滑框）

2.  **列表内容**：
    *   使用Table组件展示规则列表。
    *   列定义：
        *   **状态**：运行状态图标（绿色圆点=运行中，灰色=已停止，红色=错误）
        *   **名称**：规则名称，可点击进入监控面板
        *   **类型**：中转/中继组/链式中继（使用Tag展示）
        *   **入口**：入口节点名称和端口
        *   **目标**：目标地址和端口
        *   **连接数**：当前活动连接数
        *   **总流量**：总流入/流出流量（格式化显示，如"1.5 GB / 3.0 GB"）
        *   **操作**：
            *   启用/停用按钮（Toggle）
            *   监控按钮（进入监控面板）
            *   编辑按钮（打开编辑侧滑框）
            *   更多菜单（删除按钮（带二次确认）、测试连通性、查看日志、导出配置等）

3.  **列表功能**：
    *   支持按状态、类型筛选
    *   支持按名称、标签搜索
    *   支持分组折叠展示（按group_name分组）
    *   支持拖拽排序（修改sort_order）
    *   批量操作（批量启用/停用/删除）

4.  **空状态**：
    *   当没有任何规则时，显示空状态插画和"创建第一个转发规则"按钮。

**D. 系统参数设置页**

页面路径：`/forwarding/settings`

1.  **性能参数配置区域**：
    *   标题："性能参数配置"
    *   说明："配置转发规则的监控和统计参数，修改后对所有新建和已有规则生效。"
    *   配置项：
        *   **统计数据上报间隔**
            - 输入框，单位：秒，默认值：10
            - 说明："Agent向主控上报流量统计数据的时间间隔"
            - 范围：10-300秒
        *   **健康检查间隔**
            - 输入框，单位：秒，默认值：10
            - 说明："Agent执行链路健康检查的时间间隔"
            - 范围：5-600秒
        *   **历史数据聚合周期**
            - 下拉选择框，选项：每10分钟、每30分钟、每小时、每天
            - 默认值：每小时
            - 说明："历史流量数据从分钟级聚合到小时级的时间周期"
        *   **Realm进程崩溃重启次数**
            - 输入框，默认值：3
            - 说明："Realm进程异常退出后的自动重启次数，超过此次数将停止重启并告警"
            - 范围：1-10次
        *   **进程停止超时时间**
            - 输入框，单位：秒，默认值：5
            - 说明："发送SIGTERM后等待进程优雅退出的时间，超时后将强制kill"
            - 范围：3-30秒
    *   保存按钮

**E. Realm配置管理页**

页面路径：`/forwarding/realm-settings`

1.  **默认配置区域**：
    *   标题："Realm默认配置模板"
    *   说明："新建规则时将使用此模板生成Realm配置，您可以根据需要修改。"
    *   TOML编辑器，预填充默认配置：
        ```toml
        [log]
        level = "info"
        output = "stdout"

        [network]
        no_tcp = false
        use_udp = false
        tcp_timeout = 10
        tcp_keepalive = 30
        ```
    *   保存按钮

2.  **二进制文件管理区域**：
    *   标题："Realm二进制文件管理"
    *   说明："上传不同系统和架构的Realm二进制文件，Agent将根据系统自动选择对应版本。"
    *   文件列表Table：
        *   列：系统（Linux/Windows/macOS）、架构（x86_64/arm64/...）、版本号、文件大小、上传时间、操作（下载/删除）
    *   上传区域：
        *   系统选择下拉框
        *   架构选择下拉框
        *   版本号输入框
        *   文件上传按钮（拖拽或点击上传）
        *   上传按钮
    *   当前状态统计：已上传文件数量、总大小

**F. 测试连通性对话框**

1.  **触发方式**：
    *   在规则列表的"更多"菜单中点击"测试连通性"
    *   在创建/编辑侧滑框中点击"测试连通性"按钮（保存前测试）

2.  **对话框内容**：
    *   标题："测试链路连通性"
    *   测试步骤展示（步进器）：
        *   步骤1: 检测入口节点可达性
        *   步骤2: 检测中继节点可达性（如有）
        *   步骤3: 检测目标地址可达性
        *   步骤4: 端到端连通性测试
    *   每个步骤显示：
        *   状态图标（等待/进行中/成功/失败）
        *   延迟信息（成功时显示）
        *   错误信息（失败时显示）
    *   底部按钮：
        *   重新测试
        *   关闭

3.  **测试逻辑**：
    *   前端调用 `POST /api/v1/forwards/test-connectivity` API
    *   后端创建临时测试任务，逐步测试各节点
    *   通过WebSocket实时推送测试进度和结果

---

### 5. 数据库表补充设计

除了前面提到的 `forward_rules` 和 `forward_stats` 表，还需要以下表：

**`forward_traffic_history` - 流量历史统计表**

用于存储历史流量数据，支持趋势分析和报表功能。

| 字段名              | 类型        | 描述                           | 示例          |
| :----------------- | :---------- | :----------------------------- | :------------ |
| `id`               | `INTEGER`   | 主键，自增                      | `1`           |
| `rule_id`          | `INTEGER`   | `forward_rules`的外键          | `1`           |
| `node_id`          | `VARCHAR(36)` | 节点UUID（外键关联Client表）   | `"550e8400-e29b-41d4-a716-446655440000"` |
| `timestamp`        | `TIMESTAMP` | 记录时间（精确到分钟）           | `2024-01-01 12:00:00` |
| `connections`      | `INTEGER`   | 该时刻的连接数                  | `15`          |
| `traffic_in_bytes` | `BIGINT`    | 该时间段内入口流量（Bytes）      | `1024000`     |
| `traffic_out_bytes`| `BIGINT`    | 该时间段内出口流量（Bytes）      | `2048000`     |
| `avg_latency_ms`   | `INTEGER`   | 平均延迟（ms，如果是中继节点）   | `12`          |

索引：
- `idx_rule_timestamp`: (rule_id, timestamp) - 用于快速查询指定规则的历史数据
- `idx_node_timestamp`: (node_id, timestamp) - 用于快速查询指定节点的历史数据

数据保留策略：
- 保留最近30天的分钟级数据
- 30天以上的数据聚合为小时级数据，保留1年
- 1年以上的数据聚合为天级数据，保留3年
- 超过3年的数据自动清理

**`forward_alert_configs` - 告警配置表**

存储每个转发规则的告警配置。

| 字段名                     | 类型      | 描述                                      | 示例                    |
| :------------------------ | :-------- | :---------------------------------------- | :---------------------- |
| `id`                      | `INTEGER` | 主键，自增                                 | `1`                     |
| `rule_id`                 | `INTEGER` | `forward_rules`的外键，唯一索引            | `1`                     |
| `enabled`                 | `BOOLEAN` | 是否启用告警                               | `true`                  |
| `node_down_enabled`       | `BOOLEAN` | 节点宕机告警开关                           | `true`                  |
| `link_degraded_enabled`   | `BOOLEAN` | 链路降级告警开关                           | `true`                  |
| `link_faulty_enabled`     | `BOOLEAN` | 链路故障告警开关                           | `true`                  |
| `high_latency_enabled`    | `BOOLEAN` | 高延迟告警开关                             | `false`                 |
| `high_latency_threshold`  | `INTEGER` | 高延迟阈值（ms）                           | `200`                   |
| `traffic_spike_enabled`   | `BOOLEAN` | 流量突增告警开关                           | `false`                 |
| `traffic_spike_threshold` | `FLOAT`   | 流量突增阈值（相比平均值的倍数）            | `2.0`                   |
| `created_at`              | `TIMESTAMP` | 创建时间                                 |                         |
| `updated_at`              | `TIMESTAMP` | 更新时间                                 |                         |

**注意**：通知渠道配置使用系统全局配置，不在此表中存储。

**`forward_alert_history` - 告警历史记录表**

存储触发的告警历史。

| 字段名          | 类型        | 描述                                        | 示例                    |
| :------------- | :---------- | :------------------------------------------ | :---------------------- |
| `id`           | `INTEGER`   | 主键，自增                                   | `1`                     |
| `rule_id`      | `INTEGER`   | `forward_rules`的外键                       | `1`                     |
| `alert_type`   | `ENUM`      | 告警类型: `node_down`, `link_degraded`, `link_faulty`, `high_latency`, `traffic_spike` | `node_down` |
| `severity`     | `ENUM`      | 严重程度: `info`, `warning`, `critical`     | `critical`              |
| `message`      | `TEXT`      | 告警消息                                     | `入口节点A已离线`        |
| `details`      | `JSONB`     | 告警详细信息                                 | `{"node_id": 123, "node_name": "ServerA"}` |
| `acknowledged` | `BOOLEAN`   | 是否已确认                                   | `false`                 |
| `acknowledged_at` | `TIMESTAMP` | 确认时间                                  |                         |
| `acknowledged_by` | `VARCHAR` | 确认人                                      | `admin`                 |
| `created_at`   | `TIMESTAMP` | 告警触发时间                                 |                         |

**`realm_binaries` - Realm二进制文件管理表**

存储上传的Realm二进制文件信息。

| 字段名        | 类型        | 描述                                    | 示例                           |
| :----------- | :---------- | :-------------------------------------- | :----------------------------- |
| `id`         | `INTEGER`   | 主键，自增                               | `1`                            |
| `os`         | `ENUM`      | 操作系统: `linux`, `windows`, `macos`   | `linux`                        |
| `arch`       | `ENUM`      | 架构: `x86_64`, `arm64`, `armv7`, `i686` | `x86_64`                      |
| `version`    | `VARCHAR`   | 版本号                                   | `2.6.0`                        |
| `file_path`  | `VARCHAR`   | 文件存储路径                             | `/data/realm/linux-x86_64`     |
| `file_size`  | `BIGINT`    | 文件大小（Bytes）                        | `5242880`                      |
| `file_hash`  | `VARCHAR`   | 文件SHA256哈希值，用于校验               | `abc123...`                    |
| `is_default` | `BOOLEAN`   | 是否为该系统/架构的默认版本               | `true`                         |
| `uploaded_at`| `TIMESTAMP` | 上传时间                                 |                                |

唯一索引：`idx_os_arch_version` (os, arch, version) - 同一系统架构不允许重复版本

**`forward_system_settings` - 系统参数配置表**

存储转发系统的全局性能参数配置。

| 字段名                        | 类型      | 描述                                           | 默认值 |
| :--------------------------- | :-------- | :-------------------------------------------- | :----- |
| `id`                         | `INTEGER` | 主键（固定为1，单行表）                         | `1`    |
| `stats_report_interval`      | `INTEGER` | 统计数据上报间隔（秒）                          | `10`   |
| `health_check_interval`      | `INTEGER` | 健康检查间隔（秒）                              | `10`   |
| `history_aggregate_period`   | `VARCHAR` | 历史数据聚合周期（10min/30min/1hour/1day）      | `1hour` |
| `realm_crash_restart_limit`  | `INTEGER` | Realm进程崩溃重启次数上限                       | `3`    |
| `process_stop_timeout`       | `INTEGER` | 进程停止超时时间（秒）                          | `5`    |
| `updated_at`                 | `TIMESTAMP` | 更新时间                                      |        |

**注意**：这是一个单行配置表，始终只有一条记录（id=1）。

**`realm_config_template` - Realm默认配置模板表**

存储Realm的默认TOML配置模板，用于生成新规则时的基础配置。

| 字段名          | 类型      | 描述                                           | 默认值 |
| :------------- | :-------- | :-------------------------------------------- | :----- |
| `id`           | `INTEGER` | 主键（固定为1，单行表）                         | `1`    |
| `template_toml`| `TEXT`    | Realm默认配置模板（TOML格式）                   | (见下方示例) |
| `updated_at`   | `TIMESTAMP` | 更新时间                                      |        |

**注意**：这也是一个单行配置表，始终只有一条记录（id=1）。

**默认模板示例**：
```toml
[log]
level = "info"
output = "stdout"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30
```

---

## 数据库表总结

以下是完整的数据库表清单：

| 表名                        | 用途                           | 关键字段                    |
| :------------------------- | :---------------------------- | :------------------------- |
| `forward_rules`            | 转发规则配置（核心表）          | id, type, config_json      |
| `forward_stats`            | 实时状态与统计                 | rule_id, node_id           |
| `forward_traffic_history`  | 流量历史数据                   | rule_id, node_id, timestamp|
| `forward_alert_configs`    | 告警配置                       | rule_id                    |
| `forward_alert_history`    | 告警历史记录                   | rule_id, alert_type        |
| `realm_binaries`           | Realm二进制文件管理            | os, arch, version          |
| `forward_system_settings`  | 系统参数配置（单行表）          | id=1                       |
| `realm_config_template`    | Realm默认配置模板（单行表）     | id=1                       |

**外键关系**：
- `forward_stats.node_id` -> `Client.UUID`
- `forward_traffic_history.node_id` -> `Client.UUID`
- `forward_rules.config_json.entry_node_id` -> `Client.UUID`
- `forward_rules.config_json.*.node_id` -> `Client.UUID`

**注意**：所有涉及节点ID的字段统一使用Client.UUID（VARCHAR(36)）类型。

---

### 6. Realm配置生成规范与模板

基于对Realm仓库的研究，以下是配置生成的详细规范。

#### **6.1 配置生成原则**

1. **分节点生成**：每个参与转发的节点都会生成独立的Realm配置文件
2. **配置隔离**：每个规则的配置文件独立存储，文件名格式：`realm-rule-{rule_id}-node-{node_id}.toml`
3. **模板继承**：从系统默认模板继承 `[log]` 和 `[network]` 配置，`[endpoints]` 部分根据规则动态生成
4. **端口分配**：启动前通过CHECK_PORT任务获取可用端口，写入`current_port`字段
5. **配置保护与自动修正**：
   - **`[endpoints]` 部分**：由Agent根据转发类型和当前活跃节点动态生成，**禁止用户编辑**
     - 用户手动修改会在保存时被剥离
     - Agent在故障转移时会自动重新生成此部分
   - **`[log]` 部分**：Agent依赖固定路径读取日志，**禁止用户编辑**
     - 路径格式固定为：`/var/log/komari-agent/realm-rule-{rule_id}-node-{node_id}.log`
   - **`[network]` 部分**：部分参数需要**自动修正**以保证协议一致性
     - `use_udp`：根据`config_json.protocol`自动设置
       - protocol="tcp" → use_udp=false
       - protocol="udp" 或 "both" → use_udp=true
     - `no_tcp`：同理
       - protocol="udp" → no_tcp=true
       - protocol="tcp" 或 "both" → no_tcp=false
     - 其他参数（tcp_timeout, tcp_keepalive等）可由用户自定义

#### **6.2 链式转发实现说明**

**重要：Realm本身不支持链式转发**

根据对Realm的研究，Realm不支持显式的链式转发功能。要实现链式中继，我们采用**多实例级联**方案：

```
链式转发配置示例：
A:8881 -> B/C/D (中继组) -> G:11557 (中转) -> Target:53

实际实现：
- 节点A运行Realm，监听8881，转发到 B/C/D (负载均衡)
- 节点B/C/D各运行Realm，监听各自端口，转发到 G:11557
- 节点G运行Realm，监听11557，转发到 Target:53
```

每一跳都是独立的Realm实例，通过配置的remote字段串联起来。

#### **6.3 配置生成模板**

**模板1: Direct（中转）模式 - 入口节点配置**

```toml
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-{rule_id}-node-{node_id}.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:{entry_current_port}"
remote = "{target_host}:{target_port}"
```

示例（A:8881 -> 1.1.1.1:53）：
```toml
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-1-node-123.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:8881"
remote = "1.1.1.1:53"
```

**模板2: Relay Group（中继组）模式 - 入口节点配置**

```toml
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-{rule_id}-node-{node_id}.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:{entry_current_port}"
remote = "{relay_1_host}:{relay_1_current_port}"
extra_remotes = ["{relay_2_host}:{relay_2_current_port}", "{relay_3_host}:{relay_3_current_port}"]
balance = "{strategy}"  # "roundrobin" 或 "iphash"
```

示例（A:8881 -> B/C/D (轮询) -> Target:53）：
```toml
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-1-node-123.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:8881"
remote = "10.0.0.2:10715"
extra_remotes = ["10.0.0.3:15000", "10.0.0.4:18921"]
balance = "roundrobin"
```

**模板3: Relay Group模式 - 中继节点配置**

每个中继节点（B/C/D）都运行独立的Realm实例：

```toml
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-{rule_id}-node-{node_id}.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:{relay_current_port}"
remote = "{target_host}:{target_port}"
```

示例（中继节点B的配置）：
```toml
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-1-node-124.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:10715"
remote = "1.1.1.1:53"
```

**模板4: Chain（链式中继）模式**

链式中继需要为每一跳生成配置。

假设链路：A:8881 -> B/C/D (轮询) -> G:11557 -> Target:53

**节点A配置（入口）：**
```toml
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-1-node-123.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:8881"
remote = "10.0.0.2:10715"
extra_remotes = ["10.0.0.3:15000", "10.0.0.4:18921"]
balance = "roundrobin"
```

**节点B/C/D配置（第一跳中继组）：**
```toml
# 节点B
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-1-node-124.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:10715"
remote = "10.0.0.5:11557"  # 指向下一跳节点G
```

**节点G配置（第二跳中转）：**
```toml
[log]
level = "info"
output = "/var/log/komari-agent/realm-rule-1-node-125.log"

[network]
no_tcp = false
use_udp = false
tcp_timeout = 10
tcp_keepalive = 30

[[endpoints]]
listen = "0.0.0.0:11557"
remote = "1.1.1.1:53"  # 最终目标
```

#### **6.4 配置生成算法**

**伪代码（后端实现）：**

```javascript
function generateRealmConfigs(rule) {
  const configs = {};  // key: node_id, value: toml配置字符串
  const defaultTemplate = getSystemDefaultTemplate();  // 获取系统默认模板

  if (rule.type === 'direct') {
    // 中转模式：只有入口节点需要配置
    const entryConfig = {
      log: defaultTemplate.log,
      network: defaultTemplate.network,
      endpoints: [{
        listen: `0.0.0.0:${rule.config_json.entry_current_port}`,
        remote: `${getTargetAddress(rule)}:${rule.config_json.target_port}`
      }]
    };
    configs[rule.config_json.entry_node_id] = toTOML(entryConfig);

  } else if (rule.type === 'relay_group') {
    // 中继组模式：入口节点 + 所有中继节点

    // 1. 入口节点配置
    const relayAddresses = rule.config_json.relays.map(r =>
      `${getNodeIP(r.node_id)}:${r.current_port}`
    );
    const entryConfig = {
      log: defaultTemplate.log,
      network: defaultTemplate.network,
      endpoints: [{
        listen: `0.0.0.0:${rule.config_json.entry_current_port}`,
        remote: relayAddresses[0],
        extra_remotes: relayAddresses.slice(1),
        balance: rule.config_json.strategy  // "roundrobin" 或 "iphash"
      }]
    };
    configs[rule.config_json.entry_node_id] = toTOML(entryConfig);

    // 2. 每个中继节点配置
    for (const relay of rule.config_json.relays) {
      const relayConfig = {
        log: defaultTemplate.log,
        network: defaultTemplate.network,
        endpoints: [{
          listen: `0.0.0.0:${relay.current_port}`,
          remote: `${getTargetAddress(rule)}:${rule.config_json.target_port}`
        }]
      };
      configs[relay.node_id] = toTOML(relayConfig);
    }

  } else if (rule.type === 'chain') {
    // 链式中继模式：需要递归处理每一跳

    // 1. 入口节点配置（指向第一跳）
    const firstHop = rule.config_json.hops[0];
    const firstHopTargets = getHopTargets(firstHop);
    const entryConfig = {
      log: defaultTemplate.log,
      network: defaultTemplate.network,
      endpoints: [{
        listen: `0.0.0.0:${rule.config_json.entry_current_port}`,
        remote: firstHopTargets[0],
        extra_remotes: firstHopTargets.slice(1),
        balance: firstHop.strategy || undefined
      }]
    };
    configs[rule.config_json.entry_node_id] = toTOML(entryConfig);

    // 2. 处理每一跳
    for (let i = 0; i < rule.config_json.hops.length; i++) {
      const currentHop = rule.config_json.hops[i];
      const nextTarget = (i < rule.config_json.hops.length - 1)
        ? getHopTargets(rule.config_json.hops[i + 1])[0]  // 下一跳的第一个目标
        : `${getTargetAddress(rule)}:${rule.config_json.target_port}`;  // 最终目标

      if (currentHop.type === 'direct') {
        // 直连跳
        const hopConfig = {
          log: defaultTemplate.log,
          network: defaultTemplate.network,
          endpoints: [{
            listen: `0.0.0.0:${currentHop.current_port}`,
            remote: nextTarget
          }]
        };
        configs[currentHop.node_id] = toTOML(hopConfig);

      } else if (currentHop.type === 'relay_group') {
        // 中继组跳
        for (const relay of currentHop.relays) {
          const relayConfig = {
            log: defaultTemplate.log,
            network: defaultTemplate.network,
            endpoints: [{
              listen: `0.0.0.0:${relay.current_port}`,
              remote: nextTarget
            }]
          };
          configs[relay.node_id] = toTOML(relayConfig);
        }
      }
    }
  }

  return configs;
}
```

---

### 7. Agent进程管理详细设计

#### **7.1 Realm进程生命周期管理**

**进程管理器 (RealmProcessManager)**

```go
type RealmProcess struct {
    RuleID      int
    NodeID      int
    PID         int
    ConfigPath  string
    LogPath     string
    StartTime   time.Time
    Status      string  // "running", "stopped", "crashed"
    CrashCount  int     // 崩溃计数器
    LastCrash   time.Time
}

type RealmProcessManager struct {
    processes map[string]*RealmProcess  // key: "rule-{ruleId}-node-{nodeId}"
    mu        sync.RWMutex
}
```

**启动流程（伪代码）**

	```go
	func (m *RealmProcessManager) Start(ruleID, nodeID int, config string) error {
	    key := fmt.Sprintf("rule-%d-node-%d", ruleID, nodeID)

    // 1. 写入配置文件
    configPath := fmt.Sprintf("/etc/komari-agent/realm/%s.toml", key)
    if err := os.WriteFile(configPath, []byte(config), 0644); err != nil {
        return err
    }

	    // 2. 设置日志路径
	    logPath := fmt.Sprintf("/var/log/komari-agent/realm-%s.log", key)

	    // 3. 配置统计规则（用于流量统计，nftables 优先，iptables 兜底）
	    // 统计链必须只计数不改语义：链内使用 RETURN/return，而不是 ACCEPT。
	    statsInfo, err := m.setupStatsRules(ruleID, nodeID, config)
	    if err != nil {
	        // 不阻塞 Realm 启动：统计失败只影响监控数据，不应导致转发不可用
	        log.Warnf("setup stats failed: %v", err)
	    }

	    // 4. 启动Realm进程（使用fork）
	    cmd := exec.Command("./realm", "-c", configPath)
	    cmd.Stdout = openLogFile(logPath)
	    cmd.Stderr = cmd.Stdout

	    if err := cmd.Start(); err != nil {
	        m.cleanupStatsRules(statsInfo)  // 回滚
	        return err
	    }

    // 5. 记录进程信息
    process := &RealmProcess{
        RuleID:     ruleID,
        NodeID:     nodeID,
        PID:        cmd.Process.Pid,
        ConfigPath: configPath,
        LogPath:    logPath,
        StartTime:  time.Now(),
        Status:     "running",
        CrashCount: 0,
    }

    m.mu.Lock()
    m.processes[key] = process
    m.mu.Unlock()

    // 6. 启动监控goroutine
    go m.monitorProcess(key, cmd.Process)

    return nil
}
```

**停止流程（伪代码）**

```go
func (m *RealmProcessManager) Stop(ruleID, nodeID int) error {
    key := fmt.Sprintf("rule-%d-node-%d", ruleID, nodeID)

    m.mu.RLock()
    process, exists := m.processes[key]
    m.mu.RUnlock()

    if !exists {
        return fmt.Errorf("process not found")
    }

    // 1. 发送SIGTERM信号，尝试优雅关闭
    if err := syscall.Kill(process.PID, syscall.SIGTERM); err != nil {
        if err == syscall.ESRCH {
            // 进程已经不存在，直接清理
            goto cleanup
        }
    }

    // 2. 等待进程退出（最多5秒）
    timeout := time.After(5 * time.Second)
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    for {
        select {
        case <-timeout:
            // SIGTERM超时，使用SIGKILL强制终止
            log.Warnf("Process %s did not respond to SIGTERM, sending SIGKILL", key)
            if err := syscall.Kill(process.PID, syscall.SIGKILL); err != nil {
                if err != syscall.ESRCH {
                    log.Errorf("Failed to kill process %s: %v", key, err)
                }
            }

            // 再等待2秒
            time.Sleep(2 * time.Second)

            // 检查进程是否真的被终止
            if processExists(process.PID) {
                // kill -9 都无法终止，这是非常异常的情况
                errMsg := fmt.Sprintf("Process %d cannot be killed even with SIGKILL", process.PID)
                log.Errorf(errMsg)
                reportError(ruleID, nodeID, "process_unkillable", fmt.Errorf(errMsg))
                // 继续清理其他资源
            }
            goto cleanup

        case <-ticker.C:
            // 检查进程是否已退出
            if !processExists(process.PID) {
                goto cleanup
            }
        }
    }

	cleanup:
	    // 3. 清理统计规则（与启动时一致：nftables 或 iptables/ip6tables）
	    if err := m.cleanupStatsRules(ruleID, nodeID); err != nil {
	        log.Errorf("Failed to cleanup stats rules: %v", err)
	        reportError(ruleID, nodeID, "stats_cleanup_failed", err)
	    }

    // 4. 更新进程状态
    m.mu.Lock()
    process.Status = "stopped"
    delete(m.processes, key)
    m.mu.Unlock()

    return nil
}
```

**进程监控与自动重启（伪代码）**

```go
func (m *RealmProcessManager) monitorProcess(key string, process *os.Process) {
    // 等待进程退出
    state, err := process.Wait()

    m.mu.Lock()
    p := m.processes[key]
    m.mu.Unlock()

    if p == nil {
        return  // 进程已被手动停止
    }

    // 进程异常退出
    if !state.Success() || err != nil {
        p.Status = "crashed"
        p.CrashCount++
        p.LastCrash = time.Now()

        log.Errorf("Realm process %s crashed, exit code: %d", key, state.ExitCode())

        // 检查崩溃次数
        if p.CrashCount >= 3 {
            // 连续崩溃3次，上报主控，不再重启
            reportError(p.RuleID, p.NodeID, "realm_crashed_multiple_times",
                fmt.Errorf("crashed %d times, last crash: %v", p.CrashCount, p.LastCrash))

            p.Status = "failed"
            return
        }

        // 等待一段时间后重启（避免快速重启循环）
        time.Sleep(5 * time.Second)

        log.Infof("Attempting to restart Realm process %s (attempt %d/3)", key, p.CrashCount)

        // 重新读取配置并启动
        config, err := os.ReadFile(p.ConfigPath)
        if err != nil {
            reportError(p.RuleID, p.NodeID, "restart_failed", err)
            return
        }

        // 重启（这会创建新的监控goroutine）
        if err := m.Start(p.RuleID, p.NodeID, string(config)); err != nil {
            reportError(p.RuleID, p.NodeID, "restart_failed", err)
        }
    }
}
```

**进程健康检查（伪代码）**

```go
func (m *RealmProcessManager) HealthCheck(ruleID, nodeID int) bool {
    key := fmt.Sprintf("rule-%d-node-%d", ruleID, nodeID)

    m.mu.RLock()
    process, exists := m.processes[key]
    m.mu.RUnlock()

    if !exists || process.Status != "running" {
        return false
    }

    // 检查进程是否还存在
    return processExists(process.PID)
}

func processExists(pid int) bool {
    process, err := os.FindProcess(pid)
    if err != nil {
        return false
    }

    // 发送信号0检查进程是否存活
    err = process.Signal(syscall.Signal(0))
    return err == nil
}
```

#### **7.2 Realm日志管理**

**日志存储结构**

```
/var/log/komari-agent/
├── realm-rule-1-node-123.log      # 当前日志
├── realm-rule-1-node-123.log.1    # 轮转日志
├── realm-rule-1-node-124.log
└── ...
```

**日志管理API（Agent端实现）（伪代码）**

```go
// 获取日志内容
func (a *Agent) GetRealmLog(ruleID, nodeID int, lines int) (string, error) {
    logPath := fmt.Sprintf("/var/log/komari-agent/realm-rule-%d-node-%d.log", ruleID, nodeID)

    // 使用tail命令获取最后N行
    cmd := exec.Command("tail", "-n", strconv.Itoa(lines), logPath)
    output, err := cmd.Output()
    if err != nil {
        return "", err
    }

    return string(output), nil
}

// 清空日志
func (a *Agent) ClearRealmLog(ruleID, nodeID int) error {
    logPath := fmt.Sprintf("/var/log/komari-agent/realm-rule-%d-node-%d.log", ruleID, nodeID)
    return os.Truncate(logPath, 0)
}

// 删除日志
func (a *Agent) DeleteRealmLog(ruleID, nodeID int) error {
    logPath := fmt.Sprintf("/var/log/komari-agent/realm-rule-%d-node-%d.log", ruleID, nodeID)
    return os.Remove(logPath)
}

// 删除所有日志
func (a *Agent) DeleteAllRealmLogs() error {
    pattern := "/var/log/komari-agent/realm-*.log*"
    matches, err := filepath.Glob(pattern)
    if err != nil {
        return err
    }

    for _, match := range matches {
        if err := os.Remove(match); err != nil {
            log.Errorf("Failed to delete log %s: %v", match, err)
        }
    }

    return nil
}
```

---

### 8. 配置热更新流程

当用户修改规则配置并保存时，系统需要智能识别哪些节点的配置发生了变化，并仅对这些节点进行更新。

#### **8.1 配置变更检测算法**

**主控端实现（伪代码）**

```go
func DetectConfigChanges(oldRule, newRule *ForwardRule) map[int]string {
    changes := make(map[int]string)  // key: node_id, value: new_config

    // 1. 生成新旧配置
    oldConfigs := generateRealmConfigs(oldRule)
    newConfigs := generateRealmConfigs(newRule)

    // 2. 找出所有相关节点
    allNodeIDs := getAllNodeIDs(oldRule, newRule)

    // 3. 逐个对比
    for _, nodeID := range allNodeIDs {
        oldConfig := oldConfigs[nodeID]
        newConfig := newConfigs[nodeID]

        // 节点在新配置中不存在，需要停止
        if newConfig == "" {
            changes[nodeID] = "STOP"
            continue
        }

        // 节点在旧配置中不存在，需要启动
        if oldConfig == "" {
            changes[nodeID] = newConfig
            continue
        }

        // 配置内容发生变化，需要更新
        if oldConfig != newConfig {
            changes[nodeID] = newConfig
        }

        // 配置未变化，无需操作
    }

    return changes
}

func getAllNodeIDs(rules ...*ForwardRule) []int {
    nodeSet := make(map[int]bool)

    for _, rule := range rules {
        if rule == nil {
            continue
        }

        // 入口节点
        nodeSet[rule.ConfigJSON.EntryNodeID] = true

        // 中继节点
        if rule.Type == "relay_group" {
            for _, relay := range rule.ConfigJSON.Relays {
                nodeSet[relay.NodeID] = true
            }
        }

        // 链式中继的跳节点
        if rule.Type == "chain" {
            for _, hop := range rule.ConfigJSON.Hops {
                if hop.Type == "direct" {
                    nodeSet[hop.NodeID] = true
                } else {
                    for _, relay := range hop.Relays {
                        nodeSet[relay.NodeID] = true
                    }
                }
            }
        }

        // 目标节点（如果是node类型）
        if rule.ConfigJSON.TargetType == "node" {
            nodeSet[rule.ConfigJSON.TargetNodeID] = true
        }
    }

    nodeIDs := make([]int, 0, len(nodeSet))
    for id := range nodeSet {
        nodeIDs = append(nodeIDs, id)
    }

    return nodeIDs
}
```

#### **8.2 热更新执行流程**

```
用户保存配置
    ↓
主控端检测配置变更 (DetectConfigChanges)
    ↓
下发更新任务到各Agent
    ↓
Agent执行更新:
    1. 停止旧Realm进程
    2. 清理旧统计规则（nftables/iptables）
    3. 检查端口可用性
    4. 写入新配置文件
    5. 设置新统计规则（nftables 优先，iptables 兜底）
    6. 启动新Realm进程
    ↓
Agent上报结果
    ↓
主控更新数据库状态
```

**Agent端热更新实现（伪代码）**

```go
func (a *Agent) UpdateRealmConfig(ruleID, nodeID int, newConfig string) error {
    key := fmt.Sprintf("rule-%d-node-%d", ruleID, nodeID)

    // 1. 停止旧进程
    if err := a.processManager.Stop(ruleID, nodeID); err != nil {
        log.Errorf("Failed to stop old process: %v", err)
        // 继续执行，可能进程已经不存在
    }

    // 等待一小段时间，确保端口释放
    time.Sleep(500 * time.Millisecond)

    // 2. 启动新进程
    if err := a.processManager.Start(ruleID, nodeID, newConfig); err != nil {
        // 启动失败，上报错误
        return fmt.Errorf("failed to start new process: %w", err)
    }

    log.Infof("Successfully updated Realm config for %s", key)
    return nil
}
```

#### **8.3 原子性保证**

为了保证热更新的原子性，采用以下策略：

1. **顺序更新**：按照流量方向的**逆序**更新节点（从目标到入口）
   - 先更新下游节点，再更新上游节点
   - 避免上游已更新但下游未就绪导致的连接失败

2. **超时回滚**：如果更新过程中某个节点失败
   - 停止所有已更新的节点
   - 恢复旧配置
   - 重新启动

3. **版本标记**：在配置中加入版本号
   - 每次更新时递增版本号
   - Agent启动时检查版本号，确保使用最新配置

**主控端更新协调器（伪代码）**

```go
func (s *Server) UpdateRule(ruleID int, newConfig *ForwardRule) error {
    // 1. 获取旧配置
    oldRule, err := s.db.GetRule(ruleID)
    if err != nil {
        return err
    }

    // 2. 检测变更
    changes := DetectConfigChanges(oldRule, newRule)
    if len(changes) == 0 {
        return nil  // 无变更
    }

    // 3. 确定更新顺序（逆流量方向）
    updateOrder := getUpdateOrder(newRule, changes)

    // 4. 逐个更新节点
    for _, nodeID := range updateOrder {
        newConfigStr := changes[nodeID]

        if newConfigStr == "STOP" {
            // 停止节点
            err := s.sendTaskToAgent(nodeID, TaskStopRealm{
                RuleID: ruleID,
                NodeID: nodeID,
            })
        } else {
            // 更新节点
            err := s.sendTaskToAgent(nodeID, TaskUpdateRealm{
                RuleID:    ruleID,
                NodeID:    nodeID,
                NewConfig: newConfigStr,
            })
        }

        if err != nil {
            // 更新失败，回滚
            s.rollbackUpdate(ruleID, oldRule, updateOrder[:i])
            return fmt.Errorf("update failed at node %d: %w", nodeID, err)
        }
    }

    // 5. 清理不再参与的节点的历史数据
    removedNodeIDs := getRemovedNodes(oldRule, newRule)
    if len(removedNodeIDs) > 0 {
        if err := s.db.CleanupNodeHistory(ruleID, removedNodeIDs); err != nil {
            log.Errorf("Failed to cleanup history for removed nodes: %v", err)
            // 不阻塞更新流程，仅记录错误
        }
    }

    // 6. 更新数据库
    newRule.UpdatedAt = time.Now()
    return s.db.UpdateRule(newRule)
}

func getRemovedNodes(oldRule, newRule *ForwardRule) []int {
    // 获取旧规则中的所有节点
    oldNodes := make(map[int]bool)
    for _, nodeID := range getAllNodeIDs(oldRule) {
        oldNodes[nodeID] = true
    }

    // 获取新规则中的所有节点
    newNodes := make(map[int]bool)
    for _, nodeID := range getAllNodeIDs(newRule) {
        newNodes[nodeID] = true
    }

    // 找出被移除的节点
    removed := []int{}
    for nodeID := range oldNodes {
        if !newNodes[nodeID] {
            removed = append(removed, nodeID)
        }
    }

    return removed
}

func getUpdateOrder(rule *ForwardRule, changes map[int]string) []int {
    // 构建节点依赖关系，返回逆序列表
    // 简化实现：目标节点 -> 中继节点 -> 入口节点
    order := []int{}

    // 目标节点
    if rule.ConfigJSON.TargetType == "node" {
        if _, changed := changes[rule.ConfigJSON.TargetNodeID]; changed {
            order = append(order, rule.ConfigJSON.TargetNodeID)
        }
    }

    // 中继节点或链式节点
    // ...（根据规则类型添加）

    // 入口节点
    if _, changed := changes[rule.ConfigJSON.EntryNodeID]; changed {
        order = append(order, rule.ConfigJSON.EntryNodeID)
    }

    return order
}
```

---

### 9. Agent任务类型完整定义

以下是所有Agent任务类型的详细定义，包括请求格式和响应格式。

#### **9.1 CHECK_PORT - 端口检测并返回可用端口**

**功能**：检测指定端口或端口范围的可用性，返回一个可用的端口号。

**Request Payload**:
```json
{
  "port_spec": "8881",           // 固定端口 | "8000-9000" 范围 | "8881,8882,8883" 列表
  "excluded_ports": [8080, 8081] // 可选：需要排除的端口（如已被其他规则占用）
}
```

**Agent处理逻辑**:
1. 解析`port_spec`
2. 生成候选端口列表
3. 逐个检测端口可用性（使用`ss -tlnp | grep :PORT` 或 `netstat`）
4. 跳过`excluded_ports`中的端口
5. 返回第一个可用端口

**Response**:
```json
{
  "success": true,
  "available_port": 8881,
  "message": "Port 8881 is available"
}
```

或失败时：
```json
{
  "success": false,
  "available_port": null,
  "message": "No available port found in range 8000-9000"
}
```

---

#### **9.2 PREPARE_FORWARD_ENV - 转发环境预检查与安装**

**功能**：检查并安装Realm与“流量统计依赖”（nftables/iptables）等环境依赖。

**Request Payload**:
```json
{
  "realm_download_url": "https://komari-server.com/api/v1/realm/binaries/download?os=linux&arch=x86_64",
  "force_reinstall": false  // 是否强制重新下载Realm
}
```

**Agent处理逻辑**:
1. 端口放行（Firewall）检测：仅用于“是否需要自动放行端口”，不影响流量统计方式选择
   - `firewalld`：若 `firewall-cmd --state` 为 `running`
   - `ufw`：若 `ufw status` 为 `Status: active`
   - 否则：若存在 `iptables/ip6tables/nft`，则使用对应工具；若都不满足则不做放行
2. 流量统计（Stats）检测：与 Firewall 解耦
   - 若系统已启用 nftables 且存在可用的 `input/output` hook 基础链，则优先采用 nftables counter 方案
   - 否则确保存在 `iptables` 或 `ip6tables`（若没有则尝试安装 `iptables` 作为保底统计方案）
2. 检查Realm二进制文件
   - 检查路径：`/usr/local/bin/realm` 或 Agent运行目录
   - 如果不存在或`force_reinstall=true`，从`realm_download_url`下载
   - 重命名为`realm`并添加执行权限：`chmod +x realm`
   - 验证文件可执行：`./realm --version`
3. 创建必要的目录
   - `/etc/komari-agent/realm/` - 配置文件目录
   - `/var/log/komari-agent/` - 日志目录

**Response**:
```json
{
  "success": true,
  "firewall_tool": "iptables",
  "realm_version": "2.6.0",
  "message": "Environment prepared successfully"
}
```

---

#### **9.3 START_REALM - 启动Realm进程**

**功能**：根据配置启动Realm进程。

**Request Payload**:
```json
{
  "rule_id": 1,
  "node_id": 123,
  "config": "[log]\nlevel = \"info\"\n...",  // TOML配置内容
  "port": 8881,                              // 监听端口（用于iptables规则）
  "stats_interval": 30                        // 统计数据上报间隔（秒）
}
```

**Agent处理逻辑**:
1. 调用`RealmProcessManager.Start(ruleID, nodeID, config)`
2. 设置流量统计规则（nftables 优先，iptables 兜底；必须“只计数不改语义”，统计链以 RETURN 结束）
3. 启动定时上报goroutine，每隔`stats_interval`秒采集并上报统计数据

**Response**:
```json
{
  "success": true,
  "pid": 12345,
  "config_path": "/etc/komari-agent/realm/realm-rule-1-node-123.toml",
  "log_path": "/var/log/komari-agent/realm-rule-1-node-123.log",
  "message": "Realm process started successfully"
}
```

---

#### **9.4 STOP_REALM - 停止Realm进程**

**功能**：停止指定的Realm进程并清理资源。

**Request Payload**:
```json
{
  "rule_id": 1,
  "node_id": 123
}
```

**Agent处理逻辑**:
1. 调用`RealmProcessManager.Stop(ruleID, nodeID)`
2. 清理统计规则（与启动时的统计方式一致：nftables 或 iptables/ip6tables）
3. 停止统计数据上报goroutine

**Response**:
```json
{
  "success": true,
  "message": "Realm process stopped successfully"
}
```

---

#### **9.5 UPDATE_REALM - 热更新Realm配置**

**功能**：热更新Realm配置（先停后启）。

**Request Payload**:
```json
{
  "rule_id": 1,
  "node_id": 123,
  "new_config": "[log]\nlevel = \"debug\"\n...",
  "new_port": 8882,
  "stats_interval": 30
}
```

**Agent处理逻辑**:
1. 调用`Stop`停止旧进程
2. 等待500ms确保端口释放
3. 调用`Start`启动新进程

**Response**:
```json
{
  "success": true,
  "pid": 12346,
  "message": "Realm process updated successfully"
}
```

---

#### **9.6 GET_REALM_LOG - 获取Realm日志**

**功能**：获取指定Realm进程的日志内容。

**Request Payload**:
```json
{
  "rule_id": 1,
  "node_id": 123,
  "lines": 100  // 获取最后N行，默认100
}
```

**Agent处理逻辑**:
1. 读取日志文件最后N行：`tail -n {lines} {log_path}`

**Response**:
```json
{
  "success": true,
  "log_content": "[2024-01-01 12:00:00] INFO Starting realm...\n...",
  "lines_returned": 100
}
```

---

#### **9.7 CLEAR_REALM_LOG - 清空Realm日志**

**功能**：清空指定Realm进程的日志文件。

**Request Payload**:
```json
{
  "rule_id": 1,
  "node_id": 123
}
```

**Agent处理逻辑**:
1. 截断日志文件：`truncate -s 0 {log_path}`

**Response**:
```json
{
  "success": true,
  "message": "Log file cleared successfully"
}
```

---

#### **9.8 DELETE_REALM_LOG - 删除Realm日志**

**功能**：删除指定Realm进程的日志文件。

**Request Payload**:
```json
{
  "rule_id": 1,
  "node_id": 123
}
```

**Agent处理逻辑**:
1. 删除日志文件及其轮转文件：`rm {log_path}*`

**Response**:
```json
{
  "success": true,
  "message": "Log file deleted successfully"
}
```

---

#### **9.9 TEST_CONNECTIVITY - 测试连通性**

**功能**：测试到指定目标的网络连通性。

**Request Payload**:
```json
{
  "target_host": "1.1.1.1",
  "target_port": 53,
  "timeout": 5  // 超时时间（秒）
}
```

**Agent处理逻辑**:
1. 发起TCP连接：`net.DialTimeout("tcp", "1.1.1.1:53", 5*time.Second)`
2. 记录连接耗时作为延迟
3. 立即关闭连接

**Response**:
```json
{
  "success": true,
  "reachable": true,
  "latency_ms": 12,
  "message": "Target is reachable"
}
```

或失败时：
```json
{
  "success": false,
  "reachable": false,
  "latency_ms": null,
  "message": "Connection timeout after 5 seconds"
}
```

---

#### **9.10 配置变更主动上报机制 (Agent → Server)**

**触发场景**：

1. **Priority故障转移**：检测到当前节点故障，切换到备用节点
2. **Priority自动回切**：检测到高优先级节点恢复，自动切回
3. **端口冲突**：检测到端口被占用，自动切换到备用端口

**Agent处理逻辑（伪代码）**：

```go
// 当Agent修改Realm配置后，立即上报到Server
func (a *Agent) ReportConfigChange(ruleID int, nodeID string, newConfig string, updates map[string]interface{}, reason string) {
    payload := map[string]interface{}{
        "node_id": nodeID,
        "realm_config": newConfig,
        "config_json_updates": updates,
        "reason": reason,
    }

    // 调用Server的配置同步API
    resp, err := a.httpClient.Post(
        fmt.Sprintf("%s/api/v1/forwards/%d/config/sync", a.serverURL, ruleID),
        "application/json",
        marshalJSON(payload),
    )

    if err != nil {
        log.Printf("Failed to report config change: %v", err)
        // 配置已经生效,上报失败不影响转发,但记录日志供后续手动同步
        return
    }

    log.Printf("Config change reported successfully: reason=%s", reason)
}
```

**Server端处理**：

1. 接收Agent上报的配置变更
2. 更新`forward_rules`表的`realm_config`字段
3. 合并更新`config_json`字段（仅更新指定的键值对）
4. **通过WebSocket推送通知给前端**，触发UI实时更新
5. 记录配置变更历史（可选）

**WebSocket推送格式**：

```json
{
  "event": "forward_config_updated",
  "data": {
    "rule_id": 1,
    "node_id": "550e8400-...",
    "reason": "priority_failover",
    "updates": {
      "active_relay_node_id": "660e8400-...",
      "entry_current_port": 8882
    },
    "timestamp": "2024-01-01T12:00:00Z"
  }
}
```

---

### 10. 告警系统设计

#### **10.1 告警触发条件**

告警由Agent检测并上报主控，主控负责判断是否触发告警并发送通知。

**节点宕机 (node_down)**
- **触发条件**：Agent心跳超时，或Realm进程健康检查失败
- **严重程度**：Critical
- **处理**：入口节点宕机时停止整条链路并通知用户

**链路降级 (link_degraded)**
- **触发条件**：端到端测试失败，但下一跳测试成功
- **严重程度**：Warning
- **说明**：部分路径不可达，但链路可能通过其他中继节点工作

**链路故障 (link_faulty)**
- **触发条件**：入口节点的下一跳全部不可达
- **严重程度**：Critical
- **处理**：通知用户，链路已完全失效

**高延迟 (high_latency)**
- **触发条件**：中继节点延迟超过配置的阈值
- **严重程度**：Warning
- **可配置**：用户设置阈值（如200ms）

**流量突增 (traffic_spike)**
- **触发条件**：实时流量超过历史平均值的N倍
- **严重程度**：Info
- **可配置**：用户设置倍数（如2.0倍）

#### **10.2 告警配置UI**

在规则创建/编辑侧滑框中增加"告警配置"折叠区域：

```
┌─ 告警配置 ─────────────────────────┐
│ [✓] 启用告警                       │
│                                    │
│ 告警类型：                         │
│ [✓] 节点宕机告警                   │
│ [✓] 链路降级告警                   │
│ [✓] 链路故障告警                   │
│ [ ] 高延迟告警                     │
│     阈值: [200] ms                 │
│ [ ] 流量突增告警                   │
│     阈值: [2.0] 倍                 │
│                                    │
│ 通知方式：                         │
│ [✓] 站内通知                       │
│ [ ] 邮件通知                       │
│     邮箱: [admin@example.com]      │
│ [ ] Webhook                        │
│     URL: [https://...]             │
└────────────────────────────────────┘
```

#### **10.3 告警通知流程**

```
Agent检测异常
    ↓
上报主控（带详细信息）
    ↓
主控查询告警配置
    ↓
判断是否触发告警（去重、静默期）
    ↓
写入告警历史表
    ↓
使用现有通知系统发送通知（复用messageSender.SendEvent）
    ↓
前端展示告警（监控面板、通知中心）
```

**告警去重与静默期**：
- 同一类型的告警在5分钟内只触发一次
- 用户确认告警后，24小时内不再重复告警（除非恢复后再次触发）

#### **10.4 与现有通知系统集成**

**重要**：转发规则的告警通知将**复用**系统现有的通知系统，无需单独配置通知渠道。

**集成方式**：

1. **定义新的事件类型**（在 `models/messageEvent` 包中）：
```go
const (
    ForwardNodeDown     = "forward_node_down"      // 转发节点宕机
    ForwardLinkDegraded = "forward_link_degraded"  // 链路降级
    ForwardLinkFaulty   = "forward_link_faulty"    // 链路故障
    ForwardHighLatency  = "forward_high_latency"   // 高延迟
    ForwardTrafficSpike = "forward_traffic_spike"  // 流量突增
)
```

2. **发送告警通知**（主控端实现）（伪代码）：
```go
func SendForwardAlert(ruleID int, alertType string, details map[string]interface{}) error {
    // 1. 查询规则信息
    rule, err := db.GetForwardRule(ruleID)
    if err != nil {
        return err
    }

    // 2. 查询告警配置
    alertConfig, err := db.GetForwardAlertConfig(ruleID)
    if err != nil || !alertConfig.Enabled {
        return nil  // 未启用告警
    }

    // 3. 检查去重和静默期
    if shouldSuppress(ruleID, alertType) {
        return nil
    }

    // 4. 构造事件消息
    event := models.EventMessage{
        Event:   alertType,
        Time:    time.Now(),
        Message: formatAlertMessage(rule, alertType, details),
        Emoji:   getAlertEmoji(alertType),
        // 可选：附加详细信息
        Details: details,
    }

    // 5. 使用现有通知系统发送
    if err := messageSender.SendEvent(event); err != nil {
        log.Printf("Failed to send forward alert: %v", err)
        return err
    }

    // 6. 记录告警历史
    alertHistory := &models.ForwardAlertHistory{
        RuleID:    ruleID,
        AlertType: alertType,
        Severity:  getSeverity(alertType),
        Message:   event.Message,
        Details:   details,
    }
    db.Create(alertHistory)

    return nil
}

func getAlertEmoji(alertType string) string {
    switch alertType {
    case messageevent.ForwardNodeDown:
        return "🔴"
    case messageevent.ForwardLinkDegraded:
        return "🟡"
    case messageevent.ForwardLinkFaulty:
        return "⛔"
    case messageevent.ForwardHighLatency:
        return "🐌"
    case messageevent.ForwardTrafficSpike:
        return "📈"
    default:
        return "⚠️"
    }
}

func formatAlertMessage(rule *ForwardRule, alertType string, details map[string]interface{}) string {
    switch alertType {
    case messageevent.ForwardNodeDown:
        nodeName := details["node_name"].(string)
        return fmt.Sprintf("转发规则 [%s] 的节点 %s 已离线", rule.Name, nodeName)
    case messageevent.ForwardLinkDegraded:
        return fmt.Sprintf("转发规则 [%s] 链路降级，部分路径不可达", rule.Name)
    case messageevent.ForwardLinkFaulty:
        return fmt.Sprintf("转发规则 [%s] 链路故障，所有路径不可达", rule.Name)
    case messageevent.ForwardHighLatency:
        latency := details["latency"].(int)
        threshold := details["threshold"].(int)
        return fmt.Sprintf("转发规则 [%s] 延迟过高：%dms（阈值：%dms）", rule.Name, latency, threshold)
    case messageevent.ForwardTrafficSpike:
        currentTraffic := details["current_traffic"].(float64)
        avgTraffic := details["avg_traffic"].(float64)
        return fmt.Sprintf("转发规则 [%s] 流量突增：%.2f Mbps（平均：%.2f Mbps）", rule.Name, currentTraffic, avgTraffic)
    default:
        return fmt.Sprintf("转发规则 [%s] 触发告警", rule.Name)
    }
}
```

3. **通知渠道配置**：
   - 用户通过 `/admin/settings/notification` 页面配置全局通知渠道（邮件、Webhook、Telegram等）
   - 转发规则告警自动使用全局配置的通知渠道
   - 在规则的告警配置中，仅需配置：
     - 是否启用告警
     - 各类告警的开关和阈值
     - ~~无需单独配置通知渠道~~

4. **告警配置UI简化**：
```
┌─ 告警配置 ─────────────────────────┐
│ [✓] 启用告警                       │
│                                    │
│ 告警类型：                         │
│ [✓] 节点宕机告警                   │
│ [✓] 链路降级告警                   │
│ [✓] 链路故障告警                   │
│ [ ] 高延迟告警                     │
│     阈值: [200] ms                 │
│ [ ] 流量突增告警                   │
│     阈值: [2.0] 倍                 │
│                                    │
│ 📌 通知渠道使用系统全局配置        │
│    前往 设置 > 通知 进行配置       │
└────────────────────────────────────┘
```

**优势**：
- ✅ 复用现有通知基础设施，无需重复开发
- ✅ 统一的通知渠道管理
- ✅ 支持现有的所有通知方式（邮件、Webhook、Telegram等）
- ✅ 降低用户配置复杂度

---

### 11. 实现路线图

#### **阶段1：基础架构**
- [x] 数据库迁移与模型落库（`forward_rules` + 系统参数表，含`config_json`、告警配置字段）
- [x] 主控↔Agent任务协议梳理与落地（CHECK_PORT、PREPARE_FORWARD_ENV、START/STOP/UPDATE_REALM等请求/响应体）
- [x] Agent基础框架搭建（任务处理器、进程管理器、健康检查器）
- [x] 环境预检/安装流程（防火墙类型检测、端口放行前置、Realm二进制安装/校验）
- [x] Realm配置生成器（覆盖direct/relay_group/chain三模式 + priority故障转移策略）

#### **阶段2：核心功能**
- [x] 前端UI实现（规则列表、创建/编辑侧滑框、系统参数、Realm模板，告警折叠区待补）
- [x] 系统参数配置页面实现
- [x] Direct模式完整流程打通（前端配置校验+type落盘，启动/停止已可用，后续联调监控/告警）
- [x] Relay Group模式实现（含priority策略的健康检查与active_relay_node_id维护，主控回写待补）
- [x] Chain模式实现（多跳配置表单已接入，后端配置生成已覆盖）
- [x] 端口实时冲突检测 + 自动分配 + 自动防火墙放行（前后端均已接入，可在表单中检测/填充可用端口）
- [x] Realm配置编辑页/接口（前端支持编辑/保存入口Realm TOML；中继侧视图/批量下发待补）
- [x] 规则启动/停止下发链路（主控→Agent，WS同步等待结果）
- [x] forward_stats 写入与 WS 推送骨架（链路状态实时更新的后端通路，Agent 初步上报）
- [x] Priority健康检测与active_relay_node_id自动切换（Agent侧基础版已生效，主控回写/前端展示待补）
- [x] Iptables流量统计采集与周期上报（Agent侧定期上报，主控入库 forward_stats，前端展示待接）
- [x] 告警配置接口与前端折叠区（单规则告警可读写，通知触发逻辑待补）

#### **阶段3：监控与统计**
- [x] Agent端iptables流量采集与上报（采样周期、去抖）→ 主控聚合入库
- [x] 监控面板UI实现（实时连接数、流量、链路状态、当前活跃节点/延迟）
- [x] 链路拓扑图可视化（基于实时健康状态与活跃节点标记）
- [x] 历史数据采集与聚合（含按30天/1年/3年规则的聚合与清理）

#### **阶段4：高级功能**
- [x] 热更新流程实现（逆流量方向更新 + 失败回滚）
- [x] 告警系统实现（复用通知系统，含去重/静默）
- [x] 新增转发告警事件类型（messageevent包，含验证）
- [x] Realm日志管理（尾读/清空/删除接口）
- [x] 测试连通性功能（Agent接口 + 前端入口）
- [x] Realm二进制管理页面
